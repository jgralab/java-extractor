module java/type/ClassifierDeclarations
imports
  java/member/Modifiers     %% Modifier
  java/Identifiers   %% Id
  java/type/Types         %% ClassifierType, TypeParam
  java/member/Members       %% Member, InitializerBlock, EnumConstants, AnnotationElementDecl
  
global actions
	pattern _ -> ClassifierDeclaration #
		$ = $0;
	#

exports
  sorts ClassDeclaration InterfaceDeclaration EnumDeclaration AnnotationDeclaration ClassifierDeclaration

  context-free syntax

    %% Classes
	@Symboltable{name2TypeParameter}
    rule #
			$ = ClassDefinition();
			$qualifiedNamePrefix= {return qualifiedNamePrefix;};
		 #
		 (
			Modifier #HasTypeModifier($, $0);#
			| (Annotation #HasTypeAnnotation($, $0);#)
		 )* "class" Id #
			{qualifiedNamePrefix += "." + #lexem($2)#;}
			$.name = lexem($2);
			$.external = false;
			$.fullyQualifiedName = {return qualifiedNamePrefix;};
		 #
         ("<" {TypeParam #DeclaresClassTypeParameter($, $0);# ","}+ #{utilities.correctTypeParameterUsage((SymbolTableStack) #name2TypeParameter#, (Vertex) #$#);}# ">")?
         ("extends" ClassifierType #ExtendsClass($, $1);#)?
         ("implements" {ClassifierType #ImplementedInterfacesFromClass($, $0);# ","}+)?
         ClassifierBody #ContainsTypeMember($, $6);#
		 -> ClassDeclaration #{qualifiedNamePrefix = (String) #$qualifiedNamePrefix#;}#

    %% Enums
	@Symboltable{name2TypeParameter}
    rule  #
			$ = EnumDefinition();
			$qualifiedNamePrefix= {return qualifiedNamePrefix;};
		 #
		 (
			Modifier #HasTypeModifier($, $0);#
			| (Annotation #HasTypeAnnotation($, $0);#)
		 )* "enum" Id #
			{qualifiedNamePrefix += "." + #lexem($2)#;}
			$.name = lexem($2);
			$.external = false;
			$.fullyQualifiedName = {return qualifiedNamePrefix;};
		 #
         ("implements" {ClassifierType #ImplementedInterfacesFromEnum($, $0);# ","}+)?
         EnumBody  #ContainsTypeMember($, $4);#
		 -> EnumDeclaration  #{qualifiedNamePrefix = (String) #$qualifiedNamePrefix#;}#
    rule "{" EnumConstants (";"
             %% All kinds of Members except for EnumConstants may follow
             (FieldDeclaration |
              MethodDeclaration | ConstructorDeclaration |
              InitializerBlock |
              ClassifierDeclaration ";"* #lift($0);#)*)? "}" -> EnumBody #$ = $1;#

    %% Interfaces
	@Symboltable{name2TypeParameter}
    rule #
			$ = InterfaceDefinition();
			$qualifiedNamePrefix= {return qualifiedNamePrefix;};
		 #
		 (
			Modifier #HasTypeModifier($, $0);#
			| (Annotation #HasTypeAnnotation($, $0);#)
		 )* "interface" Id #
			{qualifiedNamePrefix += "." + #lexem($2)#;}
			$.name = lexem($2);
			$.external = false;
			$.fullyQualifiedName = {return qualifiedNamePrefix;};
		 #
         ("<" {TypeParam #DeclaresInterfaceTypeParameter($, $0);# ","}+ #{utilities.correctTypeParameterUsage((SymbolTableStack) #name2TypeParameter#, (Vertex) #$#);}# ">")?
         ("extends" {ClassifierType #ExtendsInterfaces($, $0);# ","}+)?
         ClassifierBody #ContainsTypeMember($, $5);#
		 -> InterfaceDeclaration #{qualifiedNamePrefix = (String) #$qualifiedNamePrefix#;}#

    %% Annotations
	@Symboltable{name2TypeParameter}
    rule  #
			$ = AnnotationDefinition();
			$qualifiedNamePrefix= {return qualifiedNamePrefix;};
		 #
		 (
			Modifier #HasTypeModifier($, $0);#
			| (Annotation #HasMetaAnnotation($, $0);#)
		 )* "@" "interface" Id #
			{qualifiedNamePrefix += "." + #lexem($3)#;}
			$.name = lexem($3);
			$.external = false;
			$.fullyQualifiedName = {return qualifiedNamePrefix;};
		 #
		 AnnotationBody #ContainsTypeMember($, $4);#
		 -> AnnotationDeclaration  #{qualifiedNamePrefix = (String) #$qualifiedNamePrefix#;}#
    %% Yes, there may be enums in annotations
    rule "{" (AnnotationElementDecl | ClassifierDeclaration | FieldDeclaration ";"* #lift($0);#)* "}" -> AnnotationBody #$ = $1;#

    rule ClassDeclaration      -> ClassifierDeclaration  #$=$0;#
    rule EnumDeclaration       -> ClassifierDeclaration #$=$0;#
    rule InterfaceDeclaration  -> ClassifierDeclaration #$=$0;#
    rule AnnotationDeclaration -> ClassifierDeclaration #$=$0;#

    rule ClassifierDeclaration -> Member #$=$0;#

    rule "{" (Member | InitializerBlock ";"* #lift($0);#)* "}" -> ClassifierBody #$ = $1;#
