module java/expression/MethodsAndObjectCreations
imports
  java/type/Types %% Type ClassifierType TypeArg PlainClassifierType NonArrayType
  java/Identifiers %% Id
  java/type/ClassifierDeclarations %% ClassifierBody
  java/annotation/Annotations %% Annotation

exports
  sorts Expression
  sorts MethodSpec ArrayInit SubArrayExpression

  context-free syntax
	%% constructor call
	%% duplicate method because of priorities
    rule #
			$ = ConstructorCall();
			$method = MethodInvocation();
			$method.type = MethodInvocationTypes.CONSTRUCTOR;
			InvokesConstructor($, $method);
		#
		"new" ("<" #$typeArg = TypeArgument();#
		{
			TypeArg #{
				if (((Vertex) #$0#).isInstanceOf(getVertexClass("type.specification.SimpleArgument"))) {#
					ContainsSimpleArgument($typeArg, $0);
				#} else {#
					ContainsWildcardArgument($typeArg, $0);
				#}
			}#
			","
		}+ #HasMethodTypeArgument($method, $typeArg);#
		">")?
		ClassifierType #
			$type = $2;
			$identifier = {return utilities.getIdentifierOfConstructorType((Vertex) #$2#);};
			HasInvokedMethodName($method, $identifier);
		#
		"(" {Expression #ContainsCurrentParameter($method, $0);# ","}* ")"
		#
			$isLocalVariable = {return isLocalVariable;};
			{isLocalVariable = false;}
		#
		ClassifierBody #
				%% create anonymous class
				$anonymousType = ClassDefinition();
				$name = {return "";// TODO create qualified name for anonymous class};
				$anonymousType.name = $name;
				$qName = {return qualifiedNamePrefix + "." + #$name#;//TODO check};
				$anonymousType.fullyQualifiedName = $qName;
				$identifier = name2Identifier.use($name);
				{
					if (#$identifier# == null) {#
						$identifier = Identifier();
						$identifier.name = $name;
						name2Identifier.declare($name, $identifier);
					#} else {
						getPositionsMap().put((Vertex) #$identifier#, currentElement.getParentApplicationOfDefinedRule().getPosition());
					}
				}
				HasTypeName($anonymousType, $identifier);
				ExtendsClass($anonymousType, $type);
				{//TODO check if the anonymous class extends a class or implements an interface}
				ContainsTypeMember($anonymousType, $0);
				%% create type specification
				$type = QualifiedType();
				$type.fullyQualifiedName = $qName;
				HasSimpleName($type, $identifier);
				IsDefinedByType($type, $anonymousType);
			#
		?
		#{isLocalVariable = (Boolean) #$isLocalVariable#;}#
		-> ConstructorSuffix #HasCreatedObjectType($, $type);#
	rule ConstructorSuffix -> Expression #$ = $0;#
    rule Expression "." ConstructorSuffix -> Expression #
			$ = $2;
			ContainsCalledMethod($.get_constructorInvocation(), $0);
		#
	
	%% method call or constructor calls this() (Expliciteconstructor) or super()
	rule MethodSpec #$method = $0;# "(" {Expression #ContainsCurrentParameter($method $0);# ","}* ")" -> Expression #
		$constructorCall = $method.get_consructorCall();
	{
		if (#$consructorCall# != null) {#
			$ = $consructorCall;
		#} else {#
			$ = $method;
		#}
	}#

	rule (PlainClassifierType ".")? ("<" {TypeArg "," }+ ">")? (Id|"this"|"super") -> MethodSpec
	rule    (Type ".")? "super" "." ("<" {TypeArg "," }+ ">")? (Id|"this"|"super") -> MethodSpec
	rule             Expression "." ("<" {TypeArg "," }+ ">")? (Id|"this"|"super") -> MethodSpec {avoid}
	
	%% array creation
    rule #$ = ArrayCreation();#
		"new" NonArrayType #
			expression.HasElementType($, $1);
			$dimension = 0;
		#
		(
			"["
			Expression #HasDimensionSize($, $0);# ?
			"]" #$dimension = {return ((Integer) #$dimension#) + 1;};#
		)+ -> SubArrayExpression #$.dimensions = $dimension;#
	rule SubArrayExpression #$ = $0;# ArrayInit #ContainsInitializer($, $0);# ? -> Expression
	rule #$ = ArrayInitializer();# "{" {(Expression|Annotation) #ContainsElement($, $0);# ","}* ","? "}" -> ArrayInit
	rule ArrayInit -> Expression #$ = $0;#
	
  context-free restrictions
	SubArrayExpression -/- [\[]