module java/expression/Expressions
imports
  java/expression/literals/IntegerLiterals %% IntLiteral
  java/expression/literals/FloatingPointLiterals %% FloatLiteral
  java/expression/literals/BooleanLiterals  %% BoolLiteral
  java/expression/literals/CharacterLiterals  %% CharLiteral
  java/expression/literals/StringLiterals %% StringLiteral
  java/expression/literals/NullLiteral %% NullLiteral
  java/type/Types %% Type ClassifierType
  java/Identifiers %% Id
  java/expression/Operations %% Expression
  java/expression/MethodsAndObjectCreations %% Expression
  java/expression/Priorities

exports
  sorts Expression ArrayAccess SubArrayAccess

  context-free syntax
	rule IntLiteral    -> Expression #$ = {return utilities.getLiteral((String) #lexem($0)#, currentElement.getPosition());};#
    rule FloatLiteral  -> Expression #$ = {return utilities.getLiteral((String) #lexem($0)#, currentElement.getPosition());};#
    rule BoolLiteral   -> Expression #$ = {return utilities.getLiteral((String) #lexem($0)#, currentElement.getPosition());};#
    rule CharLiteral   -> Expression #$ = {return utilities.getLiteral((String) #lexem($0)#, currentElement.getPosition());};#
    rule StringLiteral -> Expression #$ = {return utilities.getLiteral((String) #lexem($0)#, currentElement.getPosition());};#
    rule NullLiteral   -> Expression #$ = {return utilities.getLiteral((String) #lexem($0)#, currentElement.getPosition());};#
	
    rule Type   "." "class" -> Expression #
		$ = ClassLiteral();
		RefersToType($, $0);
	#
	
	rule #$ = ThisConstant();#
		(ClassifierType #ContainsQualifier($, $0);# ".")? "this" -> Expression

	rule "(" Expression ")"          -> Expression #$ = $1;#

    %% todo JFR-30
    rule Expression CondMid Expression -> Expression {right} #
		$ = ConditionalExpression();
		ContainsCondExpCondition($, $0);
		ContainsMatch($, $1);
		ContainsMismatch($, $2);
	#
    rule "?" Expression ":" -> CondMid {bracket} #$ = $1;#
	
	rule FieldAccess -> Expression
	
    rule Id  -> FieldAccess %% variable, local field, type parameter, enum constant
	
	rule                 Expression "." Id -> FieldAccess
    rule             Type "." Id -> FieldAccess {avoid}
    rule              "super" "." Id -> FieldAccess
    rule Type "." "super" "." Id -> FieldAccess
	
    %% todo: JFR-29
	rule ArrayAccess -> Expression
    rule Expression SubArrayAccess -> ArrayAccess
	rule "[" Expression? "]" -> SubArrayAccess

  context-free priorities
	Expression SubArrayAccess -> ArrayAccess
	<0>>
	SubArrayExpression ArrayInit? -> Expression,
	
	Expression "." Id -> FieldAccess
	<0>>{
		IntLiteral    -> Expression
		FloatLiteral  -> Expression
		BoolLiteral   -> Expression 
		CharLiteral   -> Expression
		NullLiteral   -> Expression
	}